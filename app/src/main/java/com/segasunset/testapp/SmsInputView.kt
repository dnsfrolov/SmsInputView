package com.segasunset.testappimport android.content.Contextimport android.graphics.Canvasimport android.graphics.Colorimport android.graphics.Paintimport android.graphics.Rectimport android.os.Buildimport android.os.Handlerimport android.text.Editableimport android.text.InputTypeimport android.text.TextWatcherimport android.util.AttributeSetimport android.util.Logimport android.view.Gravityimport android.view.inputmethod.InputMethodManagerimport android.widget.EditTextimport android.widget.LinearLayoutimport android.widget.TextViewimport androidx.annotation.DrawableResimport androidx.annotation.StyleRes/** * project: TestApp * date: 2019-08-13 * owner: SegaSunset * email: denis.frolov.work@gmail.com */class SmsInputView @JvmOverloads constructor(	context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr), TextWatcher {	private val TAG = this::class.java.simpleName	private val DENSITY: Int = context.resources.displayMetrics.density.toInt()	private val CURSOR_DELAY_IN_MILLIS = 350L	@DrawableRes	private var backgroundRes = R.drawable.bg_rounded_white	@DrawableRes	private var backgroundActiveRes = R.drawable.bg_rounded_blue	@DrawableRes	private var backgroundErrorRes = R.drawable.bg_rounded_red	@StyleRes	private var txtStyleRes = R.style.TextAppearance_AppCompat_Medium	private var sivPaddingWidth = 8 * DENSITY	private var sivPaddingHeight = 8 * DENSITY	private var sivSplitWidth = 8 * DENSITY	private var sivSplitHeight = 8 * DENSITY	private var inputLength = 4	private var currTextState: TextState = TextState.INACTIVE	private var activeTxtView: TextView? = null	private var isCursorVisible = true	private var isCursorActive = true	private val lineHandler = Handler()	private val txtViewList = arrayListOf<TextView>()	private val cursorPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {		color = Color.parseColor("#03A9F4")		strokeWidth = 1F * DENSITY	}	private lateinit var editText: EditText	init {		initView(context, attrs, defStyleAttr)	}	override fun afterTextChanged(s: Editable?) {	}	override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {	}	override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {		if (s == null) return		val textLength = s.length		if (textLength > inputLength) {			fallbackEditText {				val newText = editText.text.replaceFirst(".$".toRegex(), "")				fillEditText(newText, newText.length)			}			return		}		if (textLength > start || textLength != start) {			txtViewList.forEachIndexed { index, it ->				if (it.length() == 0) {					val currTxtView = txtViewList[index]					it.text = s[textLength - 1].toString()					val nextTxtPosition = index + 1					if (nextTxtPosition <= txtViewList.size - 1) {						updateTextView(currTxtView, TextState.INACTIVE)						updateTextView(txtViewList[nextTxtPosition], TextState.ACTIVE)					} else {						updateTextView(currTxtView, TextState.INACTIVE)					}					return				}			}		} else {			for (i in txtViewList.size - 1 downTo 0) {				val txtView = txtViewList[i]				if (txtView.text.isNotEmpty()) {					txtView.text = ""					val nextPosition = i + 1					if (nextPosition <= txtViewList.size - 1) updateTextView(						txtViewList[nextPosition],						TextState.INACTIVE					)					updateTextView(txtViewList[i], TextState.ACTIVE)					break				}			}		}	}	override fun dispatchDraw(canvas: Canvas?) {		super.dispatchDraw(canvas)		val left = activeTxtView?.left?.toFloat() ?: 0f		val right = activeTxtView?.right?.toFloat() ?: 0f		val top = activeTxtView?.top?.toFloat() ?: 0f		val bottom = activeTxtView?.bottom?.toFloat() ?: 0f		Log.d(TAG, "txt left[$left], right[$right], top[$top], bottom[$bottom]")		val txtSize = activeTxtView?.textSize ?: 0f		val bottomLine = bottom - ((bottom - txtSize) / 2)		val topLine = bottom - bottomLine + top		Log.d(TAG, "txt topLine[$topLine]")		Log.d(TAG, "txt bottomLine[$bottomLine]")		if (isCursorActive) {			canvas?.drawLine(				right - (right - left) / 2,				topLine,				right - (right - left) / 2,				bottomLine,				cursorPaint			)		}	}	private fun initView(context: Context, attrs: AttributeSet?, defStyleAttr: Int) {		gravity = Gravity.CENTER		val tr = context.obtainStyledAttributes(attrs, R.styleable.SmsInputView, defStyleAttr, 0)		backgroundRes = tr.getResourceId(R.styleable.SmsInputView_sivBackground, backgroundRes)		backgroundActiveRes = tr.getResourceId(R.styleable.SmsInputView_sivBackgroundActive, backgroundActiveRes)		backgroundErrorRes = tr.getResourceId(R.styleable.SmsInputView_sivBackgroundError, backgroundErrorRes)		txtStyleRes = tr.getResourceId(R.styleable.SmsInputView_sivTextStyle, txtStyleRes)		isCursorVisible = tr.getBoolean(R.styleable.SmsInputView_sivIsCursorVisible, isCursorVisible)		sivPaddingWidth = tr.getDimensionPixelOffset(R.styleable.SmsInputView_sivPaddingWidth, sivPaddingWidth)		sivPaddingHeight = tr.getDimensionPixelOffset(R.styleable.SmsInputView_sivPaddingHeight, sivPaddingHeight)		sivSplitWidth = tr.getDimensionPixelOffset(R.styleable.SmsInputView_sivSplitWidth, sivSplitWidth)		sivSplitHeight = tr.getDimensionPixelOffset(R.styleable.SmsInputView_sivSplitHeight, sivSplitHeight)		val length = tr.getInteger(R.styleable.SmsInputView_sivLength, inputLength)		inputLength = if (length <= 1) inputLength else length		tr.recycle()		configureView(context)	}	fun setText(newText: String) {		val newTextLength = newText.length		if (newText.isEmpty() || newText.isBlank() || newTextLength > inputLength) return		fallbackEditText {			updateAllTextView(TextState.INACTIVE, clearValue = true)			fillEditText(newText, newTextLength)			val isLengthEquals = newTextLength == inputLength			run {				txtViewList.forEachIndexed { index, textView ->					if (index > newTextLength - 1) return@run					textView.text = newText[index].toString()					if (isLengthEquals) updateTextView(textView, TextState.INACTIVE)				}			}			if (!isLengthEquals) {				updateTextView(txtViewList[newTextLength], TextState.ACTIVE)			}		}	}	private fun configureView(context: Context) {		this.setOnClickListener {			editText.requestFocus()			openKeyboard()			run loop@{				txtViewList.forEach {					if (it.length() == 0) {						updateTextView(it, TextState.ACTIVE)						return@loop					}				}			}		}		configureTextViews(context)		configureEditText(context)	}	private fun configureTextViews(context: Context) {		for (i in 0 until inputLength) {			val txtView = TextView(context).apply {				gravity = Gravity.CENTER				setBackgroundResource(backgroundRes)				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {					setTextAppearance(txtStyleRes)				} else {					setTextAppearance(context, txtStyleRes)				}				val bounds = Rect()				paint.getTextBounds("0", 0, 1, bounds)				val width = paint.measureText("0")				val fm = paint.fontMetrics				val height = fm.descent - fm.ascent				layoutParams =					LayoutParams(width.toInt() + sivPaddingWidth * 2, height.toInt() + sivPaddingHeight * 2)				val marginParams = layoutParams as MarginLayoutParams				val calcSplitWidth = sivSplitWidth / 2				val calcSplitHeight = sivSplitHeight / 2				marginParams.setMargins(calcSplitWidth, calcSplitHeight, calcSplitWidth, calcSplitHeight)			}			txtViewList.add(txtView)			addView(txtView)		}	}	private fun configureEditText(context: Context) {		editText = EditText(context).apply {			layoutParams = LayoutParams(1, 1)			background = null			isCursorVisible = false			inputType = InputType.TYPE_CLASS_NUMBER		}		editText.addTextChangedListener(this)		editText.setOnFocusChangeListener { _, hasFocus ->			if (!hasFocus) updateAllTextView(TextState.INACTIVE)		}		addView(editText)	}	private fun fallbackEditText(fallbackBlock: () -> Unit) {		editText.removeTextChangedListener(this)		fallbackBlock.invoke()		editText.addTextChangedListener(this)	}	private fun fillEditText(text: String, textLength: Int) {		editText.setText(text)		editText.setSelection(textLength)	}	private fun updateTextView(txtView: TextView, state: TextState, clearValue: Boolean = false) {		lineHandler.removeMessages(0)		activeTxtView = null		isCursorActive = false		currTextState = state		if (clearValue) txtView.text = ""		when (currTextState) {			TextState.ACTIVE -> {				txtView.setBackgroundResource(backgroundActiveRes)				activeTxtView = txtView				if (isCursorVisible) {					isCursorActive = true					lineHandler.postDelayed(object : Runnable {						override fun run() {							isCursorActive = !isCursorActive							this@SmsInputView.postInvalidate()							lineHandler.postDelayed(this, CURSOR_DELAY_IN_MILLIS)						}					}, CURSOR_DELAY_IN_MILLIS)				}			}			TextState.ERROR -> txtView.setBackgroundResource(backgroundErrorRes)			else -> txtView.setBackgroundResource(backgroundRes)		}	}	private fun updateAllTextView(state: TextState, clearValue: Boolean = false) {		txtViewList.forEach { updateTextView(it, state, clearValue) }	}	private fun openKeyboard() {		val inputMethodManager = context?.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager		inputMethodManager.toggleSoftInput(InputMethodManager.SHOW_IMPLICIT, InputMethodManager.HIDE_IMPLICIT_ONLY)	}	private enum class TextState {		ACTIVE, INACTIVE, ERROR	}}